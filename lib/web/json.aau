//json 编解码

namespace web.json
var push = ..table.push;
var indexAny = ..string.indexAny;
var find = ..string.find;
var sub = ..string.sub;
var match = ..string.match;
var replace = ..string.replace;
var concat = ..string.concat;
var join = ..string.join;
var format = ..string.format;
var repeat = ..string.repeat;
var fromUnicode = ..string.fromUnicode;
var toUnicode = ..string.toUnicode;

var scanWhiteSpace = function(s,pos){
	if(!#s)return;
	var whiteSpace = '\t \n\r\xA1';//空格不能放在字串起始处
 
	for(i=1;#s){
	    if( not indexAny(  whiteSpace , s[pos])  )
	       break;
	    pos ++;
	}
 
	return pos;
}

var scanComment = function(str,pos){ 
	var endPos = find(str,"*/",pos+2);
	assert(endPos != null,"Unterminated comment in string at "+pos);
	return endPos+2;
}
 
var scanObject = function(str,unescape,pos,codepage){ 
	var object = { @{ _defined = {};_type="object" } };
	var len = #str;
	var key,value; 
	pos++;
	
	do{
		pos = scanWhiteSpace(str,pos);
			
		if( str[pos] == ','# || str[pos] == ';'# )
			pos = scanWhiteSpace(str,pos+1);
	
	 	if( str[pos] == '}'# )
			return object,pos+1;
			
	    if(pos > len )error("json格式错误 - 溢出",2)
	    
	    //是注释的话跳过
	    if(str[pos] == '/'# && str[pos+1] == '*'# ){
	    	pos = scanComment(str,pos);
	    }
	    else{	    
	    	//扫描key
			key,pos = scanAny(str,unescape,pos,true,codepage);
			if(pos>len || (key===null) )
				error("json格式错误 - 读取key时溢出" ,2)
	    	 
	    	pos = scanWhiteSpace(str,pos);	    
	    	if( str[pos] != ':'# && str[pos] != '='#)
	    		error("json格式错误 - 预期':',靠近:" + sub(str,pos,pos+10),2)
	 
	    	pos = scanWhiteSpace(str,pos+1);	 
	    	value,pos = scanAny(str,unescape,pos,,codepage);
	    	object[key] = value;  
	    	..table.push( object@._defined,key );
	    }
	}while(true)
}

var ind=0;
var scanArray = function(str,unescape,pos,codepage){ 
	var array = { @{_type="array"} }; 
	var strLen = #str; 	
	pos ++; 
	while(pos <= strLen ){
		pos = scanWhiteSpace(str,pos); 
		if( str[pos] == ','# || str[pos] == ';'# ){
			pos = scanWhiteSpace(str,pos+1);
	    } 
	    if( str[pos] == ']'# ){ 
			return array,pos+1;
		} 
	    
	    //是注释的话跳过
	    if(str[pos] == '/'# && str[pos+1] == '*'# ){
	    	pos = scanComment(str,pos);
	    }else{
	    	object,pos = scanAny(str,unescape,pos,,codepage); 
	    	push(array,object);
	    }
	} 
	error("json格式错误 - 溢出",2)
}
 

var scanString = function(str,unescape,pos=1,codepage){ 
 
	var startChar = str[pos + 0 /*非数字强制出错*/]; 
	if(str[pos+1]==startChar)
		return "",pos+2;
	var endPos=pos+1;   
	var chr;
	var escaped;
	for(i=pos+1;#str;1){ 
		chr = str[i] 
		if(chr=='\\'#){ 
			if(str[i+1]<0x80){ i++;escaped=true; };
		}
		elseif(chr==startChar){ 
			break;
		}
		elseif(chr>0x80){ 
			i++;
		}
		
		endPos = i;
	}
	var s = sub(str,pos+1,endPos);
	if( escaped ? unescape ){
		s = decodeString(s,codepage);
	} 
	
	return s,endPos+2;
}

var consts = {
	["true"] = true;
	["false"] = false; 
	["null"] = null;
};  

var scanConstant = function(str,pos,isKey){ 
	if(str[pos]==','#)
		return null,pos;
	 
	var nextStr = sub(str,pos); 	
	var n,l = tonumber( nextStr );
    if(n!==null) return n,pos+l;
	
    var token = match(nextStr,"^[_$\a]\w*");
    if( token ){ 
    	if( isKey ) return token,pos+#token;
    	
    	var const = consts[token];  
    	if( const===null && token!="null" ){ 
    		return token,pos+#token;
    	}
    		
    	return const,pos+#token; 
    }  
    
	error("json格式错误 - 常量"+sub(str,pos),3)
}
 
decodeString = function(s,codepage){
	if( !find(s,":") ){ //不允许混用编码与非编码宽字符
		s = replace( s, "<\\u\x\x\x\x>+", 
    		function(u){
        		return fromUnicode( eval("'" + u + "'"),codepage)
    		}
		)   
	}
	
	return replace(s, '(<:+>|<\\\\[\x01-\x7f]>|.)', { 
		["\b"] = '\b';
		["\f"] = '\f';
		["\n"] = '\n';
		["\r"] = '\r';
		["\t"] = '\t';
		['\\"'] = '"';
		["\\"] = "\";
		["\/"] = "/";
		["\0"] = '\0';
	} ) 
} 

var toJsonString;
toJsonString = function(v,fm,unicodeEscaped,objreferences){
    select(type(v)) {
    	case "table" {
    		if(!objreferences) objreferences = {};
    		if(objreferences[v]) return "{}";
    		objreferences[v] = true;
        	return stringify(v,fm,unicodeEscaped,objreferences);
    	} 
    	case "string"{ 
    		v = replace(v, '(<\x80-\xFF.>|.)', { 
				['\\'] = "\\" ;
				['"'] = '\\"' ;
				['\0'] = "\0" ;
				['\r'] = "\r" ;
				['\n'] = "\n" ;
				['\t'] = "\t" ;
				['\b'] = "\b" ;
				['\f'] = "\f" ;
			} ) 
    	    if( unicodeEscaped ){ 
    	    	v = replace( v, '(<\x80-\xFF.>+)', 
    				function(c){ 
    					return replace( toUnicode(c,,false),"(..)",function(c){
    						return format("\u%02x%02x", c[2],c[1])
    					}) 
    				}
				)   
    	    } 
        	return concat('"',v,'"'); 
    	}
    	else{
        	return  tostring(v);
    	} 
    
    }
}

var levels = 0;
var indent = '\32\32\32\32';
stringify = function(tab,fm,unicodeEscaped,objreferences) {
	if( unicodeEscaped === null ) unicodeEscaped = !fm; 
	if( type(tab) != "table" )
		return ( tostring(tab) ) ;
	 
	var LFCR = "";
	var curIndent;
	if(fm){
		levels++;
		LFCR = '\r\n';
		curIndent = repeat(levels,indent);
	}
		
	var len = #tab;  
	var dataType = tab@[["_type"]];
	if( ( len && (dataType != "object") ) || dataType == "array" ){ 
		var array = {}
		for(i=1;len ){ 
			var s = ( fm ? concat( curIndent, toJsonString( tab[i],fm,unicodeEscaped,objreferences ) ) : toJsonString( tab[i],fm,unicodeEscaped,objreferences ) );
   			push( array, s );
		} 
		if(fm){
			levels--;
			curIndent = repeat(levels,indent);
		}
   		return concat("[", LFCR, join( array, ","+LFCR ), LFCR, curIndent, "]");
	}
	
	var map = {}
	for k,v in ..table.eachName(tab){ 
   		push( map
   			, concat( curIndent, toJsonString( k,fm,unicodeEscaped,objreferences  ), ":", toJsonString( v,fm,unicodeEscaped,objreferences  ) )
   			); 
	}
	
	if(fm){
		levels--;
		curIndent = repeat(levels,indent);
	}
	return  concat("{", LFCR, join( map, ","+LFCR ), LFCR, curIndent, "}" );
}

scanAny = function(s,unescape,idx,isKey,codepage){
	var pos = scanWhiteSpace(s,idx); 

    select(s[pos]) {
    	case '{'#
       		return scanObject(s,unescape,pos,codepage);
    	case '['#
    		return scanArray(s,unescape,pos,codepage); 
    	case '\"'#,39 
    		return scanString(s,unescape,pos,codepage);
    	case '/'#{
    		if(s[pos+1] == '*'#)
    			return scanComment(s,pos); 
    	}
    	case '('# {
    		var exp,e = ..string.match(s,"(%())()",pos);
    		if( exp ) return eval(exp),e + 1;
    	}
    }
    
    if( idx == 1 ){
    	var s = ..string.match(s,"^\s*<\a\w*>*\s*\((.+)\)[\s\;]*$"); //JSONP,Js expression
    	if( s ) return scanAny(s,unescape,idx,,codepage)
    }

	return scanConstant(s,pos,isKey);
}

parse = function(s,unescape=true,codepage){ 
	if( type(s) != "string" ){
		if(!s) return; error("参数错误",2)
	}	
	if( !#s ) return; 
	if( s[1] == 0xEF  && s[2] == 0xBB && s[3] == 0xBF ){
		s = ..string.fromto( ..string.right(s,-4) );
	}
	elseif( #s%2 == 0 ){
		if ( s[1] == 0xFF  && s[2] == 0xFE ){
			s = ..string.fromUnicode( ..string.right(s,-3),codepage );
		}
		elseif( s[2] == 0 && s[4] == 0 ) { //RFC4627
			s = ..string.fromUnicode(s,codepage);
		}
	}
	
	var ok,data,pos = call(scanAny,self,s,unescape,1,,codepage);
	if(!ok) error(data,2);

	return data;
}

encode = stringify;
decode = parse;

//感谢 namwonsta 贡献最初的源码

/**intellisense() 
web.json.decodeString(.(JSON转义串,代码页) = 解析JSON转义符转换为普通字符串,\n代码页为可选参数,默认为0表示默认内码
web.json.stringify( = 转换为json文本
web.json.stringify(.(表对象,是否格式化,是否使用UNICODE编码) = 表对象可在元表_defined字段中预定义可能为null值的键,\n参数@2,@3可选,默认不格式化,启用UNICODE编码\n如果指定格式化,参数@3则默认为false
web.json.parse( = 使用宽松的JSON语法解析并返回表对象,\n元素分隔符可使用分号或逗号,也可以省略,\n键值分隔符可使用冒号,也可以使用等号,键名可省略引号,\n值置于圆括号中可使用简单的表达式，\n其他错误语法的JSON抛出异常
web.json.parse(.(文本,是否解析转义,代码页) = 参数@2默认为true,代码页默认为0表示默认内码,\n返回对象的元表_defined字段记录了所有已定义的键,\n参数传入空值或空字符串返回空值
end intellisense**/